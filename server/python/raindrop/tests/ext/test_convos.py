from twisted.internet import defer, reactor

from raindrop.tests import TestCaseWithCorpus


class TestSimpleCorpus(TestCaseWithCorpus):
    def ensure_doc(self, doc, expected_doc):
        # Generate a list of the properties of the document.
        # We ignore private properties of CouchDB (start with underscore)
        # and Raindrop (start with "rd_"), as we are only testing the public
        # properties generated by our extension.
        actual_properties = sorted([key for key in doc.keys()
                                        if not key.startswith('_')
                                        and not key.startswith('rd_')])

        expected_properties = sorted([key for key in expected_doc.keys()])

        # The document should have the expected properties.
        self.failUnlessEqual(actual_properties, expected_properties,
                             repr(doc['rd_key']) + ' properties')

        # The document's properties should have the expected values.
        for property in expected_doc:
            self.failUnlessEqual(doc[property], expected_doc[property],
                                 repr(doc['rd_key']) + '::' + property)

    @defer.inlineCallbacks
    def get_docs(self, key, expected=None):
        result = yield self.doc_model.open_view(key=key, reduce=False,
                                                include_docs=True)
        rows = result['rows']
        if expected is not None:
            self.failUnlessEqual(len(rows), expected,
                                 'num rows for key ' + repr(key))
        docs = [row['doc'] for row in rows]
        defer.returnValue(docs)

    @defer.inlineCallbacks
    def put_docs(self, corpus_name, corpus_spec="*", expected=None):
        items = [d for d in self.gen_corpus_schema_items(corpus_name, corpus_spec)]
        if expected is not None:
            self.failUnlessEqual(len(items), expected)
        _ = yield self.doc_model.create_schema_items(items)
        _ = yield self.ensure_pipeline_complete()

    @defer.inlineCallbacks
    def test_convo_single(self):
        # Initialize the corpus & database.
        yield self.init_corpus('hand-rolled')

        # Process a single item - should get its own convo
        yield self.put_docs('hand-rolled', 'sent-email-simple', 1)

        msgid = ['email', 'd3d08a8a534c464881a95b75300e9011@something']
        body_schema = (yield self.doc_model.open_schemas([(msgid, 'rd.msg.body')]))[0]
        # should be one 'rd.convo.messages' and one 'rd.convo.summary' doc
        # in total in the DB.
        keys = [['rd.core.content', 'schema_id', 'rd.conv.messages'],
                ['rd.core.content', 'schema_id', 'rd.conv.summary'],
            ]
        result = yield self.doc_model.open_view(keys=keys, reduce=False,
                                                include_docs = True)
        rows = result['rows']
        self.failUnlessEqual(len(rows), 2, str(rows))
        # results should be ordered by key, so .messages first.
        self.failUnlessEqual(rows[0]['doc']['rd_schema_id'], 'rd.conv.messages')
        self.failUnlessEqual(rows[1]['doc']['rd_schema_id'], 'rd.conv.summary')
        doc_msgs = rows[0]['doc']
        doc_sum = rows[1]['doc']
        ## The document should have the expected properties/values.
        expected_doc = {
            'messages': [msgid]
        }
        self.ensure_doc(doc_msgs, expected_doc)
        expected_doc = {
            'earliest_timestamp': body_schema['timestamp'],
            'latest_timestamp': body_schema['timestamp'],
            'message_ids': [msgid],
            'unread_ids': [msgid],
            'subject': None, # our test messages have no subject!
            'target-timestamp': [['from', body_schema['timestamp']]],
            'identities': [['email', 'raindrop_test_recip2@mozillamessaging.com'],
                           ['email', 'raindrop_test_recip3@mozillamessaging.com'],
                           ['email', 'raindrop_test_recip@mozillamessaging.com'],
                           ['email', 'raindrop_test_user@mozillamessaging.com'],
                            ],
        }
        self.ensure_doc(doc_sum, expected_doc)

    @defer.inlineCallbacks
    def test_convo_deleted(self):
        _ = yield self.test_convo_single()
        # now make our one message 'deleted'.
        msgid = ['email', 'd3d08a8a534c464881a95b75300e9011@something']
        si = {
            'rd_key': msgid,
            'rd_schema_id': 'rd.msg.deleted',
            'rd_ext_id': 'rd.testsuite',
            'items' : {
                'deleted': True,
                'outgoing_state': 'outgoing',
            }
        }
        _ = yield self.doc_model.create_schema_items([si])
        _ = yield self.ensure_pipeline_complete()
        # should be one 'rd.convo.messages' and one 'rd.convo.summary' doc
        # in total in the DB.
        keys = [['rd.core.content', 'schema_id', 'rd.conv.messages'],
                ['rd.core.content', 'schema_id', 'rd.conv.summary'],
            ]
        result = yield self.doc_model.open_view(keys=keys, reduce=False,
                                                include_docs = True)
        rows = result['rows']
        self.failUnlessEqual(len(rows), 2, str(rows))
        # results should be ordered by key, so .messages first.
        self.failUnlessEqual(rows[0]['doc']['rd_schema_id'], 'rd.conv.messages')
        self.failUnlessEqual(rows[1]['doc']['rd_schema_id'], 'rd.conv.summary')
        doc_msgs = rows[0]['doc']
        doc_sum = rows[1]['doc']
        expected_doc = {
            'earliest_timestamp': None,
            'latest_timestamp': None,
            'target-timestamp': [],
            'subject': None, # our test messages have no subject!
            'message_ids': [],
            'unread_ids': [],
            'identities': [],
        }
        self.ensure_doc(doc_sum, expected_doc)

    @defer.inlineCallbacks
    def test_convo_multiple(self):
        msgid = ['email', 'd3d08a8a534c464881a95b75300e9011@something']
        msgid_reply = ['email', '78cb2eb5dbc74cdd9691dcfdb266d1b9@something']
        _ = yield self.test_convo_single()
        # add the reply.
        yield self.put_docs('hand-rolled', 'sent-email-simple-reply', 1)

        body_orig, body_reply = (yield self.doc_model.open_schemas(
                                    [(msgid, 'rd.msg.body'),
                                     (msgid_reply, 'rd.msg.body'),
                                        ]))
        # should still be exactly one convo referencing both messages.
        keys = [['rd.core.content', 'schema_id', 'rd.conv.messages'],
                ['rd.core.content', 'schema_id', 'rd.conv.summary'],
            ]
        result = yield self.doc_model.open_view(keys=keys, reduce=False,
                                                include_docs = True)
        rows = result['rows']
        self.failUnlessEqual(len(rows), 2, str(rows))
        # results should be ordered by key, so .messages first.
        self.failUnlessEqual(rows[0]['doc']['rd_schema_id'], 'rd.conv.messages')
        self.failUnlessEqual(rows[1]['doc']['rd_schema_id'], 'rd.conv.summary')
        doc_msgs = rows[0]['doc']
        doc_sum = rows[1]['doc']
        ## The document should have the expected properties/values.
        expected_doc = {
            'messages': sorted([msgid, msgid_reply]),
        }
        self.ensure_doc(doc_msgs, expected_doc)
        expected_doc = {
            'earliest_timestamp': min(body_orig['timestamp'], body_reply['timestamp']),
            'latest_timestamp': max(body_orig['timestamp'], body_reply['timestamp']),
            'unread_ids': [msgid_reply, msgid],
            'message_ids': [msgid_reply, msgid],
            'subject': 'Re', # our test reply has a simple subject!
            'target-timestamp': [['direct', body_reply['timestamp']],
                                 ['from', body_orig['timestamp']],
                                 ['personal', body_reply['timestamp']],
                                 ],
            'identities': [['email', 'raindrop_test_recip2@mozillamessaging.com'],
                           ['email', 'raindrop_test_recip3@mozillamessaging.com'],
                           ['email', 'raindrop_test_recip@mozillamessaging.com'],
                           ['email', 'raindrop_test_user@mozillamessaging.com'],
                            ],
        }
        self.ensure_doc(doc_sum, expected_doc)

    @defer.inlineCallbacks
    def test_convo_combine(self):
        # in this test we introduce 2 docs with no references to each other
        # (so end up with 2 convos), then introduce a 3rd with a reference
        # to both originals - we should result in a single conversation.
        _ = yield self.init_corpus('hand-rolled')
        msg1 = """\
Delivered-To: raindrop_test_user@mozillamessaging.com
From: Raindrop Test User <Raindrop_test_user@mozillamessaging.com>
To: Raindrop Test Recipient <Raindrop_test_recip@mozillamessaging.com>
Date: Sat, 21 Jul 2009 12:13:14 -0000
Message-Id: <1234@something>

Hello
"""
        msg2 = """\
Delivered-To: raindrop_test_user@mozillamessaging.com
From: Raindrop Test User <Raindrop_test_user@mozillamessaging.com>
To: Raindrop Test Recipient <Raindrop_test_recip@mozillamessaging.com>
Date: Sat, 21 Jul 2009 12:13:14 -0000
Message-Id: <5678@something>

Hello again
"""
        # this one has the 2 references.
        msg3 = """\
Delivered-To: raindrop_test_user@mozillamessaging.com
From: Raindrop Test User <Raindrop_test_user@mozillamessaging.com>
To: Raindrop Test Recipient <Raindrop_test_recip@mozillamessaging.com>
Date: Sat, 21 Jul 2009 12:13:14 -0000
Message-Id: <90@something>
References: <1234@something> <5678@something> 

Hello again again
"""
        for (src, msgid) in [(msg1, "1234@something"), (msg2, "5678@something")]:
            si = {'rd_key': ['email', msgid],
                  'rd_schema_id': 'rd.msg.rfc822',
                  'rd_source' : None,
                  'rd_ext_id': 'rd.testsuite',
                  'items': {},
                  'attachments' : {
                        'rfc822': {
                            'data': src
                        }
                  }
                  }
            _ = yield self.doc_model.create_schema_items([si])
        _ = yield self.ensure_pipeline_complete()
        # should be 2 convos.
        key = ['rd.core.content', 'schema_id', 'rd.conv.summary']
        result = yield self.doc_model.open_view(key=key, reduce=False)
        self.failUnlessEqual(len(result['rows']), 2)
        # now the last message - one convo should vanish.
        si = {'rd_key': ['email', "90@something"],
              'rd_schema_id': 'rd.msg.rfc822',
              'rd_source' : None,
              'rd_ext_id': 'rd.testsuite',
              'items': {},
              'attachments' : {
                    'rfc822': {
                        'data': msg3
                    }
              }
              }
        _ = yield self.doc_model.create_schema_items([si])
        _ = yield self.ensure_pipeline_complete()
        # should be 1 convos.
        key = ['rd.core.content', 'schema_id', 'rd.conv.summary']
        result = yield self.doc_model.open_view(key=key, reduce=False)
        self.failUnlessEqual(len(result['rows']), 1)
        conv_id = result['rows'][0]['value']['rd_key']
        # with all 3 messages.
        key = ['rd.core.content', 'schema_id', 'rd.conv.messages']
        result = yield self.doc_model.open_view(key=key, reduce=False,
                                                include_docs=True)
        self.failUnlessEqual(len(result['rows']), 1)
        msg_ids = result['rows'][0]['doc']['messages']
        seen_ids = set([self.doc_model.hashable_key(mid) for mid in msg_ids])
        mine = set([('email', '90@something'),
                    ('email', '1234@something'),
                    ('email', '5678@something')])
        self.failUnlessEqual(seen_ids, mine)
