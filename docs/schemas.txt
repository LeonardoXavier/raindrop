Eventually we want schema definitions to live in the couch, along
with other fancy things, such as validators etc.

But for now, this is where the schema are defined.

COMMON:
=======
rd.tags:
--------
** Notes **
Anything can have tags!

** Fields **
tags: a list of tags!

MESSAGES:
=========

rd.msg.body
-----------
** Notes **
This is named 'body' in anticipation of splitting the envelope related
fields into their own schema.

** Fields **
from:  An identity ID (presumably initially an 'email' one, but other
extensions may replace with something else.)

body: the body

body_preview:

rd.msg.rfc822:
--------------
** Notes **
A schema designed to store a raw RFC822 stream

** Fields **

rfc822: attachment holding a raw rfc822 message stream.

rd.msg.email:
--------------
** Notes **
A deconstructed email message.  Note that body and envelope information
isn't stored here - extensions emiting one of these schemas will almost
certainly also emit a rd.msg.body schema which should be used.

** Fields **

headers: a dictionary holding all headers.  Header names have been lower-cased
and duplicate headers concatenated

text: only exists for non-multipart messages with a main content-type of text.

multipart_info: A list of dictionaries, with each element having elements:
  name: The name of the attachment which holds the data for this part.
  headers: A dictionary holding the headers for this sub-part.
  content_type: The type of the content stored in the attachment

rd.msg.conversation:
--------------------
** Fields **

conversation_id: a string which identifies the conversation.

rd.msg.email.mailing-list:
--------------------------
** Notes **

Information about the mailing list itself is stored in a document
with an rd.mailing-list schema.

** Fields **

list_id: a string that identifies the mailing list through which a message
         is received

rd.msg.outgoing.smtp:
---------------------
** Fields **

smtp_from: string with smtp 'from' info
smtp_to: list of strings with smtp 'to' info
smtp_body: attachment - the binary SMTP body, including all headers etc.

rd.msg.outgoing.simple:
----------------------

from: identity ID (eg, ['email', 'email@addy'])
from_display: the display name for the 'from' address
cc: optional list of identity IDs
cc_display: list of display names for the CC identities.  Must be same length
            as CC
bcc/bcc_display: as above but for bcc

Outgoing state pseudo-schemas:
------------------------------
The following pseudo-schemas are used by the 'outgoing' message handling
to record the sent state of a message.  This state is stored on the
*source* document (eg, an 'rd.msg.outgoing.simple') rather than on the
raw outgoing document.

[Note: this originally called for 2 dictionaries/objects 'outgoing_state' and
'sent_state', with each object having attributes - but this would currently
make the attributes unavailable to the megaview]

outgoing_state: one of null (meaning 'draft'), 'outgoing' (ie, in the 'outbox'
                or 'sent' (ie, message fully delivered.)
outgoing_state_timestamp: when the out_state was set.  IOW, if 'out_state' is
                   'outgoing', out_timestamp should be when they pressed the
                   'send' button.

sent_state: null, 'sending', 'sent', 'error'
sent_state_timestamp: when the send_state was set.
sent_state_reason: the 'reason' for the failure - may only make sense to
                   the protocol itself (eg, may be the SMTP error code and
                   response string)
sent_state_message: an optional message for the failure for human consumption.


MAILING LISTS:
==============

rd.mailing-list:
----------------
** Notes **

Information about a mailing list through which one or more messages have been
received.  Only the "id" field is required; the others are optional and depend
on their presence in the list-related headers of the message(s) from which
they are derived.

** Fields **

id: the ID of the mailing list, as specified by the list itself; not guaranteed
    to be unique, although we treat it like it is; we should perhaps combine it
    with the domain from which it comes to reduce the possibility of two lists
    with the same IDs being treated as the same list
name: the name of the list, if it provides one; otherwise the front-end derives
      a name from the ID
status: the status of the user's subscription to the list; can be one of
        the following values:
          subscribed: the user is subscribed to the mailing list
          (more values to follow as we implement subscription management)
post: the value of the list-post header
archive: the value of the list-archive header
help: the value of the list-help header
subscribe: the value of the list-subscribe header
unsubscribe: the value of the list-unsubscribe header


IDENTITIES AND CONTACTS:
========================

rd.contact:
** Fields **
name:


rd.identity.exists:
-------------------
** Fields **

This schema has no fields!  It could have 'identity_id', but the 'rd_key'
for such schemas is always ['identity', identity_id_value].

NOTE: Schemas with no fields are treated specially by the framework; such
records are considered an 'assertion' the object key exists, so conflict
errors are ignored when attempting to write them.

rd.identity:
------------
** Notes **
This is a 'normalized schema' - its a set of fields that any identity provider
might be able to fetch.

** Fields **

name: A display name?
nickname: nickname
url: user's home page
image: Either a URL or reference to an attachment.

rd.identity.contacts:
---------------------
** Fields **
contacts: A list of (contact_id, relationship_name) tuples, where
'relationship_name' can be None or may help differentiate things like phone
numbers or email addresses.


rd.identity.skype:
rd.identity.twitter:
--------------------

"Private" schemas - whatever the identity fetchers want to store.
